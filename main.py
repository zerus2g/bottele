# bot_final_v3.py

import sys
import os
import asyncio
import aiohttp
from flask import Flask, request
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, ContextTypes, CallbackQueryHandler

# ==============================================================================
# --- 1. PH·∫¶N C·∫§U H√åNH (CONFIG) ---
# ==============================================================================
# L·∫•y c√°c gi√° tr·ªã t·ª´ Bi·∫øn M√¥i Tr∆∞·ªùng (Environment Variables) c·ªßa Render.
BOT_TOKEN = os.environ.get("BOT_TOKEN")
if not BOT_TOKEN:
    print("L·ªñI NGHI√äM TR·ªåNG: Bi·∫øn m√¥i tr∆∞·ªùng BOT_TOKEN ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p.", file=sys.stderr)
    sys.exit(1)

TIKTOK_API_KEY = os.environ.get("TIKTOK_API_KEY", "khang")
API_URL_TEMPLATE = f"https://ahihi.x10.mx/fltik.php?user={{username}}&key={TIKTOK_API_KEY}"
PORT = int(os.environ.get("PORT", 8080))

# ==============================================================================
# --- 2. KH·ªûI T·∫†O ·ª®NG D·ª§NG BOT V√Ä FLASK SERVER ---
# ==============================================================================
application = Application.builder().token(BOT_TOKEN).build()
app = Flask(__name__)

# Kh·ªüi t·∫°o event loop to√†n c·ª•c v√† initialize bot khi app start
loop = asyncio.get_event_loop()
loop.run_until_complete(application.initialize())

# ==============================================================================
# --- 3. LOGIC C·ªêT L√ïI C·ª¶A BOT (BOT HANDLERS & CORE FUNCTIONS) ---
# ==============================================================================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """G·ª≠i tin nh·∫Øn ch√†o m·ª´ng khi ng∆∞·ªùi d√πng g√µ l·ªánh /start."""
    await update.message.reply_text("Ch√†o m·ª´ng b·∫°n! G√µ <b>/info &lt;username&gt;</b> ƒë·ªÉ tra c·ª©u.", parse_mode='HTML')

async def info(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """X·ª≠ l√Ω l·ªánh /info <username> t·ª´ ng∆∞·ªùi d√πng."""
    if context.args:
        await handle_lookup(update, context, context.args[0])
    else:
        await update.message.reply_text("C√∫ ph√°p sai. M·∫´u: <b>/info &lt;username&gt;</b>", parse_mode='HTML')

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """X·ª≠ l√Ω khi ng∆∞·ªùi d√πng nh·∫•n c√°c n√∫t b·∫•m (inline keyboard)."""
    query = update.callback_query
    await query.answer()
    if query.data and query.data.startswith("info_"):
        await handle_lookup(update, context, query.data.replace("info_", ""))

async def handle_lookup(update: Update, context: ContextTypes.DEFAULT_TYPE, username: str) -> None:
    """H√†m tra c·ª©u th√¥ng tin ch√≠nh."""
    if hasattr(update, 'message') and update.message:
        reply_obj = update.message
        status_msg = await reply_obj.reply_text("‚è≥ ƒêang tra c·ª©u...")
    elif hasattr(update, 'callback_query') and update.callback_query:
        reply_obj = update.callback_query.message
        status_msg = await reply_obj.chat.send_message("‚è≥ ƒêang tra c·ª©u l·∫°i...")
    else: return

    api_url = API_URL_TEMPLATE.format(username=username)
    try:
        timeout = aiohttp.ClientTimeout(total=15)
        async with aiohttp.ClientSession(timeout=timeout) as session:
            async with session.get(api_url) as response:
                if response.status == 200:
                    data = await response.json()
                    if data and (data.get("success") or data.get("status") == "success"):
                        await status_msg.delete()
                        await send_profile_info(reply_obj, data, username)
                    else:
                        await status_msg.edit_text(f"‚ö†Ô∏è L·ªói: {data.get('message', 'Kh√¥ng t√¨m th·∫•y user.')}")
                else:
                    await status_msg.edit_text(f"‚ö†Ô∏è L·ªói: API tra c·ª©u g·∫∑p s·ª± c·ªë (m√£ {response.status}).")
    except asyncio.TimeoutError:
        await status_msg.edit_text("‚ö†Ô∏è L·ªói: API tra c·ª©u m·∫•t qu√° nhi·ªÅu th·ªùi gian ph·∫£n h·ªìi.")
    except Exception as e:
        print(f"[CRITICAL] L·ªói kh√¥ng x√°c ƒë·ªãnh: {e}", file=sys.stderr)
        await status_msg.edit_text("‚ö†Ô∏è L·ªói: C√≥ s·ª± c·ªë kh√¥ng mong mu·ªën x·∫£y ra.")

async def send_profile_info(reply_obj, data: dict, username: str) -> None:
    """H√†m t√°ch ri√™ng ƒë·ªÉ ƒë·ªãnh d·∫°ng v√† g·ª≠i tin nh·∫Øn ch·ª©a th√¥ng tin profile."""
    actual_username = data.get('username', username)
    tiktok_url = f"https://www.tiktok.com/@{actual_username}"
    keyboard = [[InlineKeyboardButton("üîó Xem Profile TikTok", url=tiktok_url)], [InlineKeyboardButton("üîÑ Tra C·ª©u L·∫°i", callback_data=f"info_{actual_username}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    followers = data.get('followers_count', data.get('followers', 0))
    following = data.get('following_count', 0)
    msg = (f"üë§ <b>Username:</b> {data.get('username', 'N/A')}\nüè∑Ô∏è <b>Nickname:</b> {data.get('nickname', 'N/A')}\n"
           f"üë• <b>Followers:</b> {int(followers):,}\n‚û°Ô∏è <b>Following:</b> {int(following):,}")
    avatar = data.get('profilePic', data.get('profile_pic', ''))
    if avatar:
        await reply_obj.chat.send_photo(photo=avatar, caption=msg, parse_mode='HTML', reply_markup=reply_markup)
    else:
        await reply_obj.chat.send_message(text=msg, parse_mode='HTML', reply_markup=reply_markup)

# ==============================================================================
# --- 4. LOGIC C·ª¶A FLASK SERVER (WEB SERVER ROUTING) ---
# ==============================================================================
@app.route("/")
def health_check():
    """Route cho cron-job.org ping v√†o."""
    return "Bot is alive and ready!", 200

@app.route(f"/{BOT_TOKEN}", methods=["POST"])
def webhook_handler():
    try:
        update = Update.de_json(request.get_json(force=True), application.bot)
        loop.run_until_complete(application.process_update(update))
    except Exception as e:
        print(f"[Webhook Error] {e}", file=sys.stderr)
    return "OK", 200

# ==============================================================================
# --- 5. PH·∫¶N KH·ªûI CH·∫†Y (ENTRY POINT & SETUP) ---
# ==============================================================================
def setup_application():
    """H√†m ch·∫°y m·ªôt l·∫ßn khi Gunicorn kh·ªüi ƒë·ªông server ƒë·ªÉ setup bot."""
    print("B·∫Øt ƒë·∫ßu qu√° tr√¨nh thi·∫øt l·∫≠p ·ª©ng d·ª•ng bot...", file=sys.stderr)
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("info", info))
    application.add_handler(CallbackQueryHandler(button_callback))
    webhook_url = os.environ.get("RENDER_EXTERNAL_URL")
    if webhook_url:
        full_webhook_url = f"{webhook_url}/{BOT_TOKEN}"
        import requests
        set_webhook_url = f"https://api.telegram.org/bot{BOT_TOKEN}/setWebhook"
        requests.post(set_webhook_url, data={"url": full_webhook_url})
        print(f"Webhook ƒë√£ ƒë∆∞·ª£c thi·∫øt l·∫≠p t·ªõi URL: {full_webhook_url}", file=sys.stderr)
    else:
        print("Kh√¥ng t√¨m th·∫•y RENDER_EXTERNAL_URL.", file=sys.stderr)
    print("Thi·∫øt l·∫≠p ·ª©ng d·ª•ng bot ho√†n t·∫•t.", file=sys.stderr)

# Kh·ªëi l·ªánh n√†y ƒë·∫£m b·∫£o h√†m setup ƒë∆∞·ª£c ch·∫°y ƒë√∫ng c√°ch trong m√¥i tr∆∞·ªùng Gunicorn.
if __name__ != '__main__':
    setup_application()

# L·ªánh `app.run()` ch·ªâ d√πng khi b·∫°n test tr√™n m√°y c√° nh√¢n.
if __name__ == '__main__':
    app.run(host="0.0.0.0", port=PORT)
    print("ƒê·ªÉ ch·∫°y bot n√†y, h√£y d√πng m·ªôt server WSGI nh∆∞ Gunicorn. V√≠ d·ª•: gunicorn main:app")